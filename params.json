{"name":"Rtmpdump","tagline":"Mirror of git://git.ffmpeg.org/rtmpdump ","body":"RTMP Dump v2.4\r\n(C) 2009 Andrej Stepanchuk\r\n(C) 2009-2011 Howard Chu\r\n(C) 2010 2a665470ced7adb7156fcef47f8199a6371c117b8a79e399a2771e0b36384090\r\n(C) 2011 33ae1ce77301f4b4494faaa5f609f3c48b9dcf82\r\nLicense: GPLv2\r\nlibrtmp license: LGPLv2.1\r\nhttp://rtmpdump.mplayerhq.hu/\r\n\r\nTo compile type \"make\" with SYS=<platform name>, e.g.\r\n\r\n  $ make SYS=posix\r\n\r\nfor Linux, Unix, etc. or\r\n\r\n  $ make SYS=darwin\r\n\r\nfor MacOSX or\r\n\r\n  $ make SYS=mingw\r\n\r\nfor Windows.\r\n\r\nYou can cross-compile for other platforms using the CROSS_COMPILE variable:\r\n\r\n  $ make CROSS_COMPILE=arm-none-linux- INC=-I/my/cross/includes\r\n\r\nPlease read the Makefile to see what other make variables are used.\r\n\r\nThis code also requires you to have OpenSSL and zlib installed. You may\r\noptionally use GnuTLS or polarssl instead of OpenSSL if desired. You may\r\nalso build with just rtmpe support, and no rtmps/https support, by\r\nspecifying -DNO_SSL in the XDEF macro, e.g.\r\n\r\n  $ make XDEF=-DNO_SSL\r\n\r\nor\r\n\r\n  $ make CRYPTO=POLARSSL XDEF=-DNO_SSL\r\n\r\nYou may also turn off all crypto support if desired\r\n\r\n  $ make CRYPTO=\r\n\r\nA shared library is now built by default, in addition to the static\r\nlibrary. You can also turn it off if desired\r\n\r\n  $ make SHARED=\r\n\r\nThe rtmpdump programs still link to the static library, regardless.\r\n\r\nNote that if using OpenSSL, you must have version 0.9.8 or newer.\r\nFor Polar SSL you must have version 1.0.0 or newer.\r\n\r\nCredit goes to team boxee for the XBMC RTMP code originally used in RTMPDumper.\r\nThe current code is based on the XBMC code but rewritten in C by Howard Chu.\r\n\r\n\r\nSWF Verification\r\n----------------\r\n\r\nNote: these instructions for manually generating the SWFVerification\r\ninfo are provided only for historical documentation. The software can now\r\ngenerate this info automatically, so it is no longer necessary to\r\nrun the commands described here. Just use the -W (--swfVfy) option\r\nto perform automatic SWFVerification.\r\n\r\nDownload the swf player you want to use for SWFVerification, unzip it using\r\n\r\n $ flasm -x file.swf\r\n\r\nIt will show the decompressed filesize, use it for --swfsize\r\n\r\nNow generate the hash\r\n\r\n $ openssl sha -sha256 -hmac \"Genuine Adobe Flash Player 001\" file.swf\r\n\r\nand use the --swfhash \"01234...\" option to pass it.\r\n\r\ne.g. $ ./rtmpdump --swfhash \"123456...\" --swfsize 987...\r\n\r\n\r\nConnect Parameters\r\n------------------\r\n\r\nSome servers expect additional custom parameters to be attached to the\r\nRTMP connect request. The \"--auth\" option handles a specific case, where\r\na boolean TRUE followed by the given string are added to the request.\r\nOther servers may require completely different parameters, so the new\r\n\"--conn\" option has been added. This option can be set multiple times\r\non the command line, adding one parameter each time.\r\n\r\nThe argument to the option must take the form <type> : <value> where\r\ntype can be B for boolean, S for string, N for number, and O for object.\r\nFor booleans the value must be 0 or 1. Also, for objects the value must\r\nbe 1 to start a new object, or 0 to end the current object.\r\n\r\nExamples:\r\n  --conn B:0 --conn S:hello --conn N:3.14159\r\n\r\nNamed parameters can be specified by prefixing 'N' to the type. Then the\r\nname should come next, and finally the value:\r\n  --conn NB:myflag:1 --conn NS:category:something --conn NN:pi:3.14159\r\n\r\nObjects may be added sequentially:\r\n  -C O:1 -C NB:flag:1 -C NS:status:success -C O:0 -C O:1 -C NN:time:12.30 -C O:0\r\nor nested:\r\n  -C O:1 -C NS:code:hello -C NO:extra:1 -C NS:data:stuff -C O:0 -C O:0\r\n\r\n\r\nBuilding OpenSSL 0.9.8k\r\n-----------------------\r\narm:\r\n./Configure -DL_ENDIAN --prefix=`pwd`/armlibs linux-generic32\r\n\r\nThen replace gcc, cc, ar, ranlib in Makefile and crypto/Makefile by arm-linux-* variants  and use make && make install_sw\r\n\r\nwin32:\r\nTry ./Configure mingw --prefix=`pwd`/win32libs -DL_ENDIAN -DOPENSSL_NO_HW\r\nReplace gcc, cc, ... by mingw32-* variants in Makefile and crypto/Makefile\r\nmake && make install_sw\r\n\r\nOpenSSL cross-compiling can be a difficult beast.\r\n\r\nPrecompiled OpenSSL binaries for Windows are available on\r\nhttp://www.slproweb.com/products/Win32OpenSSL.html\r\n\r\nIf you're just running a pre-built Windows rtmpdump binary, then all you\r\nneed is the \"Light\" installer. If you want to compile rtmpdump yourself,\r\nyou'll need the full installer.\r\n\r\n\r\nExample Servers\r\n---------------\r\nThree different types of servers are also present in this distribution:\r\n rtmpsrv - a stub server\r\n rtmpsuck - a transparent proxy\r\n rtmpgw - an RTMP to HTTP gateway\r\n\r\nrtmpsrv - Note that this is very incomplete code, and I haven't yet decided\r\nwhether or not to finish it. It is useful for obtaining all the parameters\r\nthat a real Flash client would send to an RTMP server, so that they can be\r\nused with rtmpdump. The current version now invokes rtmpdump automatically\r\nafter parsing a client request.\r\n\r\nrtmpsuck - proxy server. See below...\r\n\r\nAll you need to do is redirect your Flash clients to the machine running this\r\nserver and it will dump out all the connect / play parameters that the Flash\r\nclient sent. The simplest way to cause the redirect is by editing /etc/hosts\r\nwhen you know the hostname of the RTMP server, and point it to localhost while\r\nrunning rtmpsrv on your machine. (This approach should work on any OS; on\r\nWindows you would edit %SystemRoot%\\system32\\drivers\\etc\\hosts.)\r\n\r\nOn Linux you can also use iptables to redirect all outbound RTMP traffic. You\r\nneed to be running as root in order to use the iptables command.\r\n\r\nIn my original plan I would have the transparent proxy running as a special\r\nuser (e.g. user \"proxy\"), and regular Flash clients running as any other user.\r\nIn that case the proxy would make the connection to the real RTMP server. The\r\niptables rule would look like this:\r\n\r\niptables -t nat -A OUTPUT -p tcp --dport 1935 -m owner \\! --uid-owner proxy \\\r\n -j REDIRECT\r\n\r\nA rule like the above will be needed to use rtmpsuck. Note that you should\r\nreplace \"proxy\" in the above command with an account that actually exists\r\non your machine.\r\n\r\nUsing it in this mode takes advantage of the Linux support for IP redirects;\r\nin particular it uses a special getsockopt() call to retrieve the original\r\ndestination address of the connection. That way the proxy can create the\r\nreal outbound connection without any other help from the user. The equivalent\r\nfunctionality may exist on other OSs but needs more investigation.\r\n\r\n(Based on reading the BSD ipfw manpage, this rule ought to work on BSD:\r\n\r\nipfw add 40 fwd 127.0.0.1,1935 tcp from any to any 1935 not uid proxy\r\n\r\nSome confirmation from any BSD users would be nice.)\r\n\r\n(We have a solution for Windows based on a TDI driver; this is known to\r\nwork on Win2K and WinXP but is assumed to not work on Vista or Win7 as the\r\nTDI is no longer used on those OS versions. Also, none of the known\r\nsolutions are available as freeware.)\r\n\r\nThe rtmpsuck command has only one option: \"-z\" to turn on debug logging.\r\nIt listens on port 1935 for RTMP sessions, but you can also redirect other\r\nports to it as needed (read the iptables docs). It first performs an RTMP\r\nhandshake with the client, then waits for the client to send a connect\r\nrequest. It parses and prints the connect parameters, then makes an\r\noutbound connection to the real RTMP server. It performs an RTMP handshake\r\nwith that server, forwards the connect request, and from that point on it\r\njust relays packets back and forth between the two endpoints.\r\n\r\nIt also checks for a few packets that it treats specially: a play packet\r\nfrom the client will get parsed so that the playpath can be displayed. It\r\nalso handles SWF Verification requests from the server, without forwarding\r\nthem to the client. (There would be no point, since the response is tied to\r\neach session's handshake.)\r\n\r\nOnce the play command is processed, all subsequent audio/video data received\r\nfrom the server will be written to a file, as well as being delivered back\r\nto the client.\r\n\r\nThe point of all this, instead of just using a sniffer, is that since rtmpsuck\r\nhas performed real handshakes with both the client and the server, it can\r\nnegotiate whatever encryption keys are needed and so record the unencrypted\r\ndata.\r\n\r\nrtmpgw - HTTP gateway: this is an HTTP server that accepts requests that\r\nconsist of rtmpdump parameters. It then connects to the specified RTMP\r\nserver and returns the retrieved data in the HTTP response. The only valid\r\nHTTP request is \"GET /\" but additional options can be provided in normal\r\nURL-encoded fashion. E.g.\r\n  GET /?r=rtmp:%2f%2fserver%2fmyapp&y=somefile HTTP/1.0\r\n\r\nis equivalent the rtmpdump parameters \"-r rtmp://server/myapp -y somefile\".\r\n\r\nNote that only the shortform (single letter) rtmpdump options are supported.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}